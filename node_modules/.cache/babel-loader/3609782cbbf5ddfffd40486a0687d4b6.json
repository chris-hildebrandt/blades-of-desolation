{"ast":null,"code":"import _defineProperty from \"C:/Users/dhild/source/mini-projects/blades-of-desolation/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { battleService } from \"./BattleService\";\nimport $store from \"@/store/index\";\nimport { Spell } from \"@/models/Spell\";\nimport { characterService } from \"./CharacterService\";\nimport { useToast } from \"vue-toastification\";\nimport { animationsService } from \"./AnimationsService\";\n\nclass SpellsService {\n  constructor() {\n    _defineProperty(this, \"toast\", useToast());\n  }\n\n  castSpell(castSpell, target) {\n    let spell = { ...castSpell\n    };\n\n    if (spell.areaEffect) {\n      if (target == 'enemies') {\n        $store.state.combatMonsters.forEach(m => {\n          spell['areaEffect'] = false;\n          this.castSpell(spell, m);\n        });\n      } else {\n        $store.state.player.characters.forEach(c => {\n          spell['areaEffect'] = false;\n          this.castSpell(spell, c);\n        });\n      }\n\n      return;\n    }\n\n    if (spell.strength && (!spell.buff || !spell.debuff)) {\n      spell['actions'] = 1;\n      spell['hp'] = 1;\n      spell['lifeSteal'] = 0;\n      spell['luck'] = 0;\n      spell['isSpell'] = true;\n      battleService.handleAttack(spell, target);\n      characterService.autoSelect();\n    }\n\n    if (spell.effect) {\n      if (Array.isArray(target[spell.effect])) {\n        target[spell.effect].push(spell.value);\n      } else if (typeof spell.value !== 'number') {\n        target[spell.effect] = spell.value;\n      } else {\n        if (spell.buff) {\n          target[spell.effect] += spell.value;\n          animationsService.fadeOutUp('hit' + target.id, spell.value, '+');\n        } else {\n          target[spell.effect] -= spell.value;\n        }\n      }\n    } // buffs/debuffs are removed at end of battle, not all buff/debuffs are temporary ex. healing\n\n\n    if (spell.temp) {\n      if (spell.debuff) {\n        target['debuffs'].push({\n          effect: spell.effect,\n          value: spell.value\n        });\n      }\n\n      if (spell.buff) {\n        target['buffs'].push({\n          effect: spell.effect,\n          value: spell.value\n        });\n      }\n    }\n  }\n\n  findRandomLearnableSpell(character) {\n    let spellLvl = Math.floor(Math.random() * (character.level ?? 0) / 2);\n\n    if (character.classType == 'wizard' || character.classType == 'unknown') {\n      return $store.state.spells[spellLvl][Math.floor(Math.random() * $store.state.spells[spellLvl].length)].name;\n    }\n\n    let spell = false;\n\n    do {\n      let potientalSpell = $store.state.spells[spellLvl][Math.floor(Math.random() * $store.state.spells[spellLvl].length)];\n      let canLearn = true;\n\n      if (potientalSpell.reqs) {\n        for (let req in potientalSpell.reqs) {\n          if (character[req] != potientalSpell.reqs[req]) {\n            canLearn = false;\n          }\n        }\n      }\n\n      if (canLearn) {\n        spell = potientalSpell.name;\n      }\n    } while (!spell);\n\n    return spell;\n  }\n\n  learnSpell(spellName, character) {\n    if (!this.canLearnSpell(spellName, character)) {\n      return false;\n    }\n\n    if (character.spells.find(s => s.name == spellName)) {\n      return this.levelUpSpell(spellName, character);\n    }\n\n    let spellData = $store.state.spells.find(spells => spells.find(s => s.name == spellName)).find(s => s.name == spellName);\n    character.spells.push(new Spell(spellData));\n    this.toast.success(character.name + ' Learned ' + spellName, {\n      timeout: 10000\n    });\n    return spellData;\n  }\n\n  canLearnSpell(spellName, character) {\n    if (character.baseMagic < 1) {\n      return false;\n    }\n\n    let spell = character.spells.find(s => s.name == spellName);\n\n    if (!spell) {\n      spell = $store.state.spells.find(spell => spell.find(s => s.name == spellName)).find(s => s.name == spellName);\n    } else {\n      return spell.level < character.level;\n    }\n\n    for (let req in spell.reqs) {\n      if (character[req] != spell.reqs[req] && character[req] != 'unknown' && character[req] != 'wizard') {\n        return false;\n      }\n    }\n\n    return spell.level <= character.level;\n  }\n\n  levelUpSpell(spellName, character) {\n    let spell = character.spells.find(s => s.name == spellName);\n    let originalSpell = $store.state.spells.find(spell => spell.find(s => s.name == spellName));\n    originalSpell = originalSpell.find(s => s.name == spellName);\n    spell.level++;\n\n    if (spell.strength) {\n      spell.strength += originalSpell.strength;\n    }\n\n    if (spell.value) {\n      spell.value += originalSpell.value;\n    }\n\n    this.toast.success(character.name + ' Level up ' + spellName, {\n      timeout: 10000\n    });\n    return spell;\n  }\n\n  getRandomSpellList() {\n    let newList = [[], [], [], [], [], [], [], [], [], []];\n    $store.state.spells.forEach(sl => sl.forEach(s => {\n      if (Math.floor(Math.random() * 10) > 8) {\n        newList[s.level].push(s);\n      }\n    }));\n    return newList;\n  }\n\n}\n\nexport const spellsService = new SpellsService();","map":{"version":3,"sources":["C:/Users/dhild/source/mini-projects/blades-of-desolation/src/services/SpellsService.js"],"names":["battleService","$store","Spell","characterService","useToast","animationsService","SpellsService","castSpell","target","spell","areaEffect","state","combatMonsters","forEach","m","player","characters","c","strength","buff","debuff","handleAttack","autoSelect","effect","Array","isArray","push","value","fadeOutUp","id","temp","findRandomLearnableSpell","character","spellLvl","Math","floor","random","level","classType","spells","length","name","potientalSpell","canLearn","reqs","req","learnSpell","spellName","canLearnSpell","find","s","levelUpSpell","spellData","toast","success","timeout","baseMagic","originalSpell","getRandomSpellList","newList","sl","spellsService"],"mappings":";AAAA,SAASA,aAAT,QAA8B,iBAA9B;AACA,OAAOC,MAAP,MAAmB,eAAnB;AACA,SAASC,KAAT,QAAsB,gBAAtB;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,QAAT,QAAyB,oBAAzB;AACA,SAASC,iBAAT,QAAkC,qBAAlC;;AAEA,MAAMC,aAAN,CAAmB;AAAA;AAAA,mCACTF,QAAQ,EADC;AAAA;;AAGjBG,EAAAA,SAAS,CAACA,SAAD,EAAYC,MAAZ,EAAmB;AAC1B,QAAIC,KAAK,GAAG,EAAC,GAAGF;AAAJ,KAAZ;;AACA,QAAGE,KAAK,CAACC,UAAT,EAAoB;AAClB,UAAGF,MAAM,IAAI,SAAb,EAAuB;AACrBP,QAAAA,MAAM,CAACU,KAAP,CAAaC,cAAb,CAA4BC,OAA5B,CAAoCC,CAAC,IAAI;AACvCL,UAAAA,KAAK,CAAC,YAAD,CAAL,GAAsB,KAAtB;AACA,eAAKF,SAAL,CAAeE,KAAf,EAAsBK,CAAtB;AACD,SAHD;AAID,OALD,MAKK;AACHb,QAAAA,MAAM,CAACU,KAAP,CAAaI,MAAb,CAAoBC,UAApB,CAA+BH,OAA/B,CAAuCI,CAAC,IAAI;AAC1CR,UAAAA,KAAK,CAAC,YAAD,CAAL,GAAsB,KAAtB;AACA,eAAKF,SAAL,CAAeE,KAAf,EAAsBQ,CAAtB;AACD,SAHD;AAID;;AACD;AACD;;AACD,QAAGR,KAAK,CAACS,QAAN,KAAmB,CAACT,KAAK,CAACU,IAAP,IAAe,CAACV,KAAK,CAACW,MAAzC,CAAH,EAAoD;AAClDX,MAAAA,KAAK,CAAC,SAAD,CAAL,GAAmB,CAAnB;AACAA,MAAAA,KAAK,CAAC,IAAD,CAAL,GAAc,CAAd;AACAA,MAAAA,KAAK,CAAC,WAAD,CAAL,GAAqB,CAArB;AACAA,MAAAA,KAAK,CAAC,MAAD,CAAL,GAAgB,CAAhB;AACAA,MAAAA,KAAK,CAAC,SAAD,CAAL,GAAmB,IAAnB;AACAT,MAAAA,aAAa,CAACqB,YAAd,CAA2BZ,KAA3B,EAAkCD,MAAlC;AACAL,MAAAA,gBAAgB,CAACmB,UAAjB;AACD;;AACD,QAAGb,KAAK,CAACc,MAAT,EAAgB;AACd,UAAGC,KAAK,CAACC,OAAN,CAAcjB,MAAM,CAACC,KAAK,CAACc,MAAP,CAApB,CAAH,EAAuC;AACrCf,QAAAA,MAAM,CAACC,KAAK,CAACc,MAAP,CAAN,CAAqBG,IAArB,CAA0BjB,KAAK,CAACkB,KAAhC;AACD,OAFD,MAEM,IAAG,OAAOlB,KAAK,CAACkB,KAAb,KAAuB,QAA1B,EAAmC;AACvCnB,QAAAA,MAAM,CAACC,KAAK,CAACc,MAAP,CAAN,GAAuBd,KAAK,CAACkB,KAA7B;AACD,OAFK,MAED;AACH,YAAGlB,KAAK,CAACU,IAAT,EAAc;AACZX,UAAAA,MAAM,CAACC,KAAK,CAACc,MAAP,CAAN,IAAwBd,KAAK,CAACkB,KAA9B;AACAtB,UAAAA,iBAAiB,CAACuB,SAAlB,CAA4B,QAAMpB,MAAM,CAACqB,EAAzC,EAA6CpB,KAAK,CAACkB,KAAnD,EAA0D,GAA1D;AACD,SAHD,MAGK;AACHnB,UAAAA,MAAM,CAACC,KAAK,CAACc,MAAP,CAAN,IAAwBd,KAAK,CAACkB,KAA9B;AACD;AACF;AACF,KAtCyB,CAuC1B;;;AACA,QAAGlB,KAAK,CAACqB,IAAT,EAAc;AACZ,UAAGrB,KAAK,CAACW,MAAT,EAAgB;AACdZ,QAAAA,MAAM,CAAC,SAAD,CAAN,CAAkBkB,IAAlB,CAAuB;AAACH,UAAAA,MAAM,EAAEd,KAAK,CAACc,MAAf;AAAuBI,UAAAA,KAAK,EAAElB,KAAK,CAACkB;AAApC,SAAvB;AACD;;AACD,UAAGlB,KAAK,CAACU,IAAT,EAAc;AACZX,QAAAA,MAAM,CAAC,OAAD,CAAN,CAAgBkB,IAAhB,CAAqB;AAACH,UAAAA,MAAM,EAAEd,KAAK,CAACc,MAAf;AAAuBI,UAAAA,KAAK,EAAElB,KAAK,CAACkB;AAApC,SAArB;AACD;AACF;AACF;;AACDI,EAAAA,wBAAwB,CAACC,SAAD,EAAW;AACjC,QAAIC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAYD,IAAI,CAACE,MAAL,MAAeJ,SAAS,CAACK,KAAV,IAAmB,CAAlC,CAAD,GAAuC,CAAlD,CAAf;;AACA,QAAGL,SAAS,CAACM,SAAV,IAAuB,QAAvB,IAAmCN,SAAS,CAACM,SAAV,IAAuB,SAA7D,EAAuE;AACrE,aAAOrC,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoBN,QAApB,EAA8BC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAcnC,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoBN,QAApB,EAA8BO,MAAvD,CAA9B,EAA8FC,IAArG;AACD;;AACD,QAAIhC,KAAK,GAAG,KAAZ;;AACA,OAAG;AACD,UAAIiC,cAAc,GAAGzC,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoBN,QAApB,EAA8BC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAcnC,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoBN,QAApB,EAA8BO,MAAvD,CAA9B,CAArB;AACA,UAAIG,QAAQ,GAAG,IAAf;;AACA,UAAGD,cAAc,CAACE,IAAlB,EAAuB;AACrB,aAAI,IAAIC,GAAR,IAAeH,cAAc,CAACE,IAA9B,EAAmC;AACjC,cAAGZ,SAAS,CAACa,GAAD,CAAT,IAAkBH,cAAc,CAACE,IAAf,CAAoBC,GAApB,CAArB,EAA8C;AAC5CF,YAAAA,QAAQ,GAAG,KAAX;AACD;AACF;AACF;;AACD,UAAGA,QAAH,EAAY;AACVlC,QAAAA,KAAK,GAAGiC,cAAc,CAACD,IAAvB;AACD;AACF,KAbD,QAaS,CAAChC,KAbV;;AAcA,WAAOA,KAAP;AACD;;AACDqC,EAAAA,UAAU,CAACC,SAAD,EAAYf,SAAZ,EAAsB;AAC9B,QAAG,CAAC,KAAKgB,aAAL,CAAmBD,SAAnB,EAA8Bf,SAA9B,CAAJ,EAA6C;AAC3C,aAAO,KAAP;AACD;;AACD,QAAGA,SAAS,CAACO,MAAV,CAAiBU,IAAjB,CAAsBC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAArC,CAAH,EAAmD;AACjD,aAAO,KAAKI,YAAL,CAAkBJ,SAAlB,EAA6Bf,SAA7B,CAAP;AACD;;AACD,QAAIoB,SAAS,GAAGnD,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoBU,IAApB,CAAyBV,MAAM,IAAIA,MAAM,CAACU,IAAP,CAAYC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAA3B,CAAnC,EAA0EE,IAA1E,CAA+EC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAA9F,CAAhB;AACAf,IAAAA,SAAS,CAACO,MAAV,CAAiBb,IAAjB,CAAsB,IAAIxB,KAAJ,CAAUkD,SAAV,CAAtB;AACA,SAAKC,KAAL,CAAWC,OAAX,CAAmBtB,SAAS,CAACS,IAAV,GAAe,WAAf,GAA2BM,SAA9C,EAAyD;AAACQ,MAAAA,OAAO,EAAE;AAAV,KAAzD;AACA,WAAOH,SAAP;AACD;;AACDJ,EAAAA,aAAa,CAACD,SAAD,EAAYf,SAAZ,EAAsB;AACjC,QAAGA,SAAS,CAACwB,SAAV,GAAsB,CAAzB,EAA2B;AACzB,aAAO,KAAP;AACD;;AACD,QAAI/C,KAAK,GAAGuB,SAAS,CAACO,MAAV,CAAiBU,IAAjB,CAAsBC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAArC,CAAZ;;AACA,QAAG,CAACtC,KAAJ,EAAU;AACRA,MAAAA,KAAK,GAAGR,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoBU,IAApB,CAAyBxC,KAAK,IAAIA,KAAK,CAACwC,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAA1B,CAAlC,EAAwEE,IAAxE,CAA6EC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAA5F,CAAR;AACD,KAFD,MAEK;AACH,aAAOtC,KAAK,CAAC4B,KAAN,GAAcL,SAAS,CAACK,KAA/B;AACD;;AACD,SAAI,IAAIQ,GAAR,IAAepC,KAAK,CAACmC,IAArB,EAA0B;AACxB,UAAGZ,SAAS,CAACa,GAAD,CAAT,IAAkBpC,KAAK,CAACmC,IAAN,CAAWC,GAAX,CAAlB,IAAqCb,SAAS,CAACa,GAAD,CAAT,IAAkB,SAAvD,IAAoEb,SAAS,CAACa,GAAD,CAAT,IAAkB,QAAzF,EAAkG;AAChG,eAAO,KAAP;AACD;AACF;;AACD,WAAOpC,KAAK,CAAC4B,KAAN,IAAeL,SAAS,CAACK,KAAhC;AACD;;AACDc,EAAAA,YAAY,CAACJ,SAAD,EAAYf,SAAZ,EAAsB;AAChC,QAAIvB,KAAK,GAAGuB,SAAS,CAACO,MAAV,CAAiBU,IAAjB,CAAsBC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAArC,CAAZ;AACA,QAAIU,aAAa,GAAGxD,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoBU,IAApB,CAAyBxC,KAAK,IAAIA,KAAK,CAACwC,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAA1B,CAAlC,CAApB;AACAU,IAAAA,aAAa,GAAGA,aAAa,CAACR,IAAd,CAAmBC,CAAC,IAAIA,CAAC,CAACT,IAAF,IAAUM,SAAlC,CAAhB;AAEAtC,IAAAA,KAAK,CAAC4B,KAAN;;AACA,QAAG5B,KAAK,CAACS,QAAT,EAAkB;AAChBT,MAAAA,KAAK,CAACS,QAAN,IAAkBuC,aAAa,CAACvC,QAAhC;AACD;;AACD,QAAGT,KAAK,CAACkB,KAAT,EAAe;AACblB,MAAAA,KAAK,CAACkB,KAAN,IAAe8B,aAAa,CAAC9B,KAA7B;AACD;;AACD,SAAK0B,KAAL,CAAWC,OAAX,CAAmBtB,SAAS,CAACS,IAAV,GAAe,YAAf,GAA4BM,SAA/C,EAA0D;AAACQ,MAAAA,OAAO,EAAE;AAAV,KAA1D;AACA,WAAO9C,KAAP;AACD;;AACDiD,EAAAA,kBAAkB,GAAE;AAClB,QAAIC,OAAO,GAAG,CAAC,EAAD,EAAI,EAAJ,EAAO,EAAP,EAAU,EAAV,EAAa,EAAb,EAAgB,EAAhB,EAAmB,EAAnB,EAAsB,EAAtB,EAAyB,EAAzB,EAA4B,EAA5B,CAAd;AACA1D,IAAAA,MAAM,CAACU,KAAP,CAAa4B,MAAb,CAAoB1B,OAApB,CAA4B+C,EAAE,IAAIA,EAAE,CAAC/C,OAAH,CAAWqC,CAAC,IAAI;AAChD,UAAGhB,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAc,EAAzB,IAA+B,CAAlC,EAAoC;AAClCuB,QAAAA,OAAO,CAACT,CAAC,CAACb,KAAH,CAAP,CAAiBX,IAAjB,CAAsBwB,CAAtB;AACD;AACF,KAJiC,CAAlC;AAKA,WAAOS,OAAP;AACD;;AA9HgB;;AAiInB,OAAO,MAAME,aAAa,GAAG,IAAIvD,aAAJ,EAAtB","sourcesContent":["import { battleService } from \"./BattleService\"\r\nimport $store from \"@/store/index\"\r\nimport { Spell } from \"@/models/Spell\"\r\nimport { characterService } from \"./CharacterService\"\r\nimport { useToast } from \"vue-toastification\"\r\nimport { animationsService } from \"./AnimationsService\"\r\n\r\nclass SpellsService{\r\n  toast = useToast()\r\n\r\n  castSpell(castSpell, target){\r\n    let spell = {...castSpell}\r\n    if(spell.areaEffect){\r\n      if(target == 'enemies'){\r\n        $store.state.combatMonsters.forEach(m => {\r\n          spell['areaEffect'] = false\r\n          this.castSpell(spell, m)\r\n        })\r\n      }else{\r\n        $store.state.player.characters.forEach(c => {\r\n          spell['areaEffect'] = false\r\n          this.castSpell(spell, c)\r\n        })\r\n      }\r\n      return\r\n    }\r\n    if(spell.strength && (!spell.buff || !spell.debuff)){\r\n      spell['actions'] = 1\r\n      spell['hp'] = 1\r\n      spell['lifeSteal'] = 0\r\n      spell['luck'] = 0\r\n      spell['isSpell'] = true\r\n      battleService.handleAttack(spell, target)\r\n      characterService.autoSelect()\r\n    }\r\n    if(spell.effect){\r\n      if(Array.isArray(target[spell.effect])){\r\n        target[spell.effect].push(spell.value)\r\n      }else if(typeof spell.value !== 'number'){\r\n        target[spell.effect] = spell.value\r\n      }else{\r\n        if(spell.buff){\r\n          target[spell.effect] += spell.value\r\n          animationsService.fadeOutUp('hit'+target.id, spell.value, '+')\r\n        }else{\r\n          target[spell.effect] -= spell.value\r\n        }\r\n      }\r\n    }\r\n    // buffs/debuffs are removed at end of battle, not all buff/debuffs are temporary ex. healing\r\n    if(spell.temp){\r\n      if(spell.debuff){\r\n        target['debuffs'].push({effect: spell.effect, value: spell.value})\r\n      }\r\n      if(spell.buff){\r\n        target['buffs'].push({effect: spell.effect, value: spell.value})\r\n      }\r\n    }\r\n  }\r\n  findRandomLearnableSpell(character){\r\n    let spellLvl = Math.floor((Math.random()*(character.level ?? 0))/2)\r\n    if(character.classType == 'wizard' || character.classType == 'unknown'){\r\n      return $store.state.spells[spellLvl][Math.floor(Math.random()*$store.state.spells[spellLvl].length)].name\r\n    }\r\n    let spell = false\r\n    do {\r\n      let potientalSpell = $store.state.spells[spellLvl][Math.floor(Math.random()*$store.state.spells[spellLvl].length)]\r\n      let canLearn = true\r\n      if(potientalSpell.reqs){\r\n        for(let req in potientalSpell.reqs){\r\n          if(character[req] != potientalSpell.reqs[req]){\r\n            canLearn = false\r\n          }\r\n        }\r\n      }\r\n      if(canLearn){\r\n        spell = potientalSpell.name\r\n      }\r\n    } while (!spell);\r\n    return spell\r\n  }\r\n  learnSpell(spellName, character){\r\n    if(!this.canLearnSpell(spellName, character)){\r\n      return false\r\n    }\r\n    if(character.spells.find(s => s.name == spellName)){\r\n      return this.levelUpSpell(spellName, character)\r\n    }\r\n    let spellData = $store.state.spells.find(spells => spells.find(s => s.name == spellName)).find(s => s.name == spellName)\r\n    character.spells.push(new Spell(spellData))\r\n    this.toast.success(character.name+' Learned '+spellName, {timeout: 10000})\r\n    return spellData\r\n  }\r\n  canLearnSpell(spellName, character){\r\n    if(character.baseMagic < 1){\r\n      return false\r\n    }\r\n    let spell = character.spells.find(s => s.name == spellName)\r\n    if(!spell){\r\n      spell = $store.state.spells.find(spell => spell.find(s => s.name == spellName)).find(s => s.name == spellName)\r\n    }else{\r\n      return spell.level < character.level\r\n    }\r\n    for(let req in spell.reqs){\r\n      if(character[req] != spell.reqs[req] && character[req] != 'unknown' && character[req] != 'wizard'){\r\n        return false\r\n      }\r\n    }\r\n    return spell.level <= character.level\r\n  }\r\n  levelUpSpell(spellName, character){\r\n    let spell = character.spells.find(s => s.name == spellName)\r\n    let originalSpell = $store.state.spells.find(spell => spell.find(s => s.name == spellName))\r\n    originalSpell = originalSpell.find(s => s.name == spellName)\r\n\r\n    spell.level++\r\n    if(spell.strength){\r\n      spell.strength += originalSpell.strength\r\n    }\r\n    if(spell.value){\r\n      spell.value += originalSpell.value\r\n    }\r\n    this.toast.success(character.name+' Level up '+spellName, {timeout: 10000})\r\n    return spell\r\n  }\r\n  getRandomSpellList(){\r\n    let newList = [[],[],[],[],[],[],[],[],[],[]]\r\n    $store.state.spells.forEach(sl => sl.forEach(s => {\r\n      if(Math.floor(Math.random()*10) > 8){\r\n        newList[s.level].push(s)\r\n      }\r\n    }))\r\n    return newList\r\n  }\r\n}\r\n\r\nexport const spellsService = new SpellsService()"]},"metadata":{},"sourceType":"module"}